# 观察者模式学习笔记

## 📖 模式理解

观察者模式的核心思想很简单：**当一个对象（主题）状态改变时，所有依赖它的对象（观察者）都会得到通知并自动更新**。

## 🏗️ 模式骨架（核心结构）

### 主题（被观察者）
**抽象层**：定义三个核心方法
- `attach(Observer)` - 添加观察者
- `detach(Observer)` - 移除观察者
- `notifyObservers()` - 通知所有观察者

**具体层**：实现主题逻辑
- 维护观察者列表
- 状态变化时调用 `notifyObservers()`

### 观察者
**抽象层**：定义核心更新方法
- `update(Subject)` - 接收主题通知的方法

**具体层**：实现具体的更新逻辑
- 根据主题状态变化做出响应

## 🎯 UML类图

```
                    ┌─────────────────────┐
                    │   <<interface>>     │
                    │   IProduct          │
                    │   (主题接口)          │
                    ├─────────────────────┤
                    │ + attach()          │
                    │ + detach()          │
                    │ + notifyObservers() │
                    └─────────────────────┘
                             ▲
                             │ 实现
                    ┌─────────────────────┐
                    │   Product           │
                    │  (具体主题)           │
                    ├─────────────────────┤
                    │ - observers         │
                    │ - name              │
                    │ - price             │
                    ├─────────────────────┤
                    │ + attach()          │
                    │ + detach()          │
                    │ + notifyObservers() │
                    │ + setPrice()        │
                    └─────────────────────┘
                             ▲ 管理关系
                             │ 通知
                    ┌─────────────────┐
                    │   <<interface>> │
                    │   IMember       │
                    │  (观察者接口)     │
                    ├─────────────────┤
                    │ + update()      │
                    └─────────────────┘
                             ▲
                             │ 实现
                    ┌─────────────────┐
                    │   Member        │
                    │  (具体观察者)     │
                    ├─────────────────┤
                    │ - name          │
                    ├─────────────────┤
                    │ + update()      │
                    └─────────────────┘
```

## 🔄 工作流程

1. **初始化**：主题创建观察者列表
2. **注册**：观察者通过 `attach()` 注册到主题
3. **状态变化**：主题状态改变时，调用 `notifyObservers()`
4. **通知**：`notifyObservers()` 遍历观察者列表，调用每个观察者的 `update()` 方法
5. **更新**：观察者在 `update()` 方法中执行具体的响应逻辑

## 💡 核心特征

### 1. 一对多关系
- 一个主题可以有多个观察者
- 主题不需要知道观察者的具体实现

### 2. 松耦合
- 主题和观察者之间只通过接口交互
- 可以独立改变主题或观察者，互不影响

### 3. 动态管理
- 运行时可以动态添加或移除观察者
- 观察者可以随时订阅或取消订阅

## 🎮 实例分析（OnlineStore）

### 角色对应
- **主题**：`Product`（商品）
- **观察者**：`Member`（会员）
- **事件**：商品价格变动

### 关键代码片段

```java
// 主题通知观察者的核心逻辑
public void notifyObservers() {
    for (IMember member : members) {
        member.update(this);  // 关键：调用每个观察者的update方法
    }
}

// 观察者接收通知的核心逻辑
public void update(Product product) {
    // 根据主题状态变化做出响应
    System.out.println("商品价格已更新为：" + product.getPrice());
}
```

## ✨ 模式优势

1. **解耦**：主题和观察者松耦合，易于扩展
2. **灵活**：动态管理观察者关系
3. **复用**：观察者可以被多个主题使用
4. **符合开闭原则**：新增观察者无需修改主题代码

## 🚀 实际应用场景

- **GUI事件处理**：按钮点击事件
- **消息队列**：发布-订阅系统
- **社交媒体**：粉丝关注动态
- **股票监控**：价格变动通知
- **天气预报**：天气变化推送

## 📝 个人总结

观察者模式的核心就是：**主题维护观察者列表，状态变化时通知所有观察者，观察者在update方法中做出响应**。

这个模式的关键在于理解`notifyObservers()`方法如何遍历观察者列表并调用每个观察者的`update()`方法，这就是整个模式的核心骨架。