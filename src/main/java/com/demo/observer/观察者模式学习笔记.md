# 观察者模式学习笔记

## 📖 模式理解

观察者模式的核心思想很简单：**当一个对象（主题）状态改变时，所有依赖它的对象（观察者）都会得到通知并自动更新**。

## 🏗️ 模式骨架（核心结构）

### 主题（被观察者）
**抽象层**：定义三个核心方法
- `attach(Observer)` - 添加观察者
- `detach(Observer)` - 移除观察者
- `notifyObservers()` - 通知所有观察者

**具体层**：实现主题逻辑
- 维护观察者列表
- 状态变化时调用 `notifyObservers()`

### 观察者
**抽象层**：定义核心更新方法
- `update(Subject)` - 接收主题通知的方法

**具体层**：实现具体的更新逻辑
- 根据主题状态变化做出响应

## 🎯 UML类图

```
                    ┌─────────────────────┐
                    │   <<interface>>     │
                    │   IProduct          │
                    │   (主题接口)          │
                    ├─────────────────────┤
                    │ + attach()          │
                    │ + detach()          │
                    │ + notifyObservers() │
                    └─────────────────────┘
                             ▲
                             │ 实现
                    ┌─────────────────────┐
                    │   Product           │
                    │  (具体主题)           │
                    ├─────────────────────┤
                    │ - observers         │
                    │ - name              │
                    │ - price             │
                    ├─────────────────────┤
                    │ + attach()          │
                    │ + detach()          │
                    │ + notifyObservers() │
                    │ + setPrice()        │
                    └─────────────────────┘
                             ▲ 管理关系
                             │ 通知
                    ┌─────────────────┐
                    │   <<interface>> │
                    │   IMember       │
                    │  (观察者接口)     │
                    ├─────────────────┤
                    │ + update()      │
                    └─────────────────┘
                             ▲
                             │ 实现
                    ┌─────────────────┐
                    │   Member        │
                    │  (具体观察者)     │
                    ├─────────────────┤
                    │ - name          │
                    ├─────────────────┤
                    │ + update()      │
                    └─────────────────┘
```

## 🔄 工作流程

1. **初始化**：主题创建观察者列表
2. **注册**：观察者通过 `attach()` 注册到主题
3. **状态变化**：主题状态改变时，调用 `notifyObservers()`
4. **通知**：`notifyObservers()` 遍历观察者列表，调用每个观察者的 `update()` 方法
5. **更新**：观察者在 `update()` 方法中执行具体的响应逻辑

## 💡 核心特征

### 1. 一对多关系
- 一个主题可以有多个观察者
- 主题不需要知道观察者的具体实现

### 2. 松耦合
- 主题和观察者之间只通过接口交互
- 可以独立改变主题或观察者，互不影响

### 3. 动态管理
- 运行时可以动态添加或移除观察者
- 观察者可以随时订阅或取消订阅

## 🎮 实例分析（OnlineStore）

### 角色对应
- **主题**：`Product`（商品）
- **观察者**：`Member`（会员）
- **事件**：商品价格变动

### 关键代码片段

```java
// 主题通知观察者的核心逻辑
public void notifyObservers() {
    for (IMember member : members) {
        member.update(this);  // 关键：调用每个观察者的update方法
    }
}

// 观察者接收通知的核心逻辑
public void update(Product product) {
    // 根据主题状态变化做出响应
    System.out.println("商品价格已更新为：" + product.getPrice());
}
```

## ✨ 模式优势

1. **解耦**：主题和观察者松耦合，易于扩展
2. **灵活**：动态管理观察者关系
3. **复用**：观察者可以被多个主题使用
4. **符合开闭原则**：新增观察者无需修改主题代码

## 🚀 实际应用场景

- **GUI事件处理**：按钮点击事件
- **消息队列**：发布-订阅系统
- **社交媒体**：粉丝关注动态
- **股票监控**：价格变动通知
- **天气预报**：天气变化推送

## ☕ JDK中提供的实现

在 Java 中，通过 `java.util.Observable` 类和 `java.util.Observer` 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。

### 1. Observable类

`Observable` 类是抽象目标类（被观察者），它有一个 `Vector` 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。

- **`void addObserver(Observer o)`** 方法：用于将新的观察者对象添加到集合中。

- **`void notifyObservers(Object arg)`** 方法：调用集合中的所有观察者对象的 `update`方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。

- **`void setChange()`** 方法：用来设置一个 `boolean` 类型的内部标志，注明目标对象发生了变化。当它为 `true` 时，`notifyObservers()` 才会通知观察者。

### 2. Observer 接口

`Observer` 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 `update` 方法，进行相应的工作。

**接口方法**：
```java
void update(Observable o, Object arg)
```

### 3. 使用示例对比

**我们自己实现的模式**：
```java
// 主题接口
public interface IProduct {
    void attach(IMember member);
    void detach(IMember member);
    void notifyObservers();
}

// 观察者接口
public interface IMember {
    void update(Product product);
}
```

**JDK实现的模式**：
```java
// JDK已提供Observable类（被观察者）
public class MySubject extends Observable {
    public void changeState() {
        setChanged();           // 标记状态已改变
        notifyObservers();      // 通知观察者
    }
}

// JDK已提供Observer接口
public class MyObserver implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        // 处理通知
    }
}
```

### 4. JDK实现的优势

1. **标准化**：提供了统一的观察者模式实现
2. **线程安全**：`Vector` 集合是线程安全的
3. **状态控制**：通过 `setChanged()` 控制通知时机
4. **参数传递**：`notifyObservers(Object arg)` 可以传递额外参数

### 5. 注意事项

⚠️ **JDK 9+ 已弃用**：`java.util.Observable` 和 `java.util.Observer` 从 Java 9 开始被标记为 `@Deprecated`，建议使用 `java.beans.PropertyChangeSupport` 或第三方框架（如 Guava 的 EventBus）。

## 📝 个人总结

观察者模式的核心就是：**主题维护观察者列表，状态变化时通知所有观察者，观察者在update方法中做出响应**。

这个模式的关键在于理解`notifyObservers()`方法如何遍历观察者列表并调用每个观察者的`update()`方法，这就是整个模式的核心骨架。

无论是我们自己实现还是使用JDK提供的实现，核心思想都是一样的：**一对多的依赖关系，状态变化自动通知**。